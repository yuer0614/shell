#!/bin/bash


#bash shell会将一些称为位置参数(positional parameter)的特殊变量分配给输入到命令行中的 所有参数。这也包括shell所执行的脚本名称。位置参数变量是标准的数字:$0是程序名，$1是第 一个参数，$2是第二个参数，依次类推，直到第九个参数$9。
#通俗的说是$0是脚本名称，$1-$9是sh 脚本名称 $1-$9，就是执行脚本的时候在脚本名称后输入9个参数可以用$1-$9来获取到
function a(){
i=1
for (( a = 1 ; a <= $1 ; a++ ))   #$1是外部输入的一个变量，a与外面输入的变量作比较，循环是 外面变量的值* a,a从1开始
do
   echo "本次循环a 为$a ,i 为 $i"
  i=$[ $i * $a]
done
echo "$1的乘阶是 $i"
}
#想要使用这个脚本把 funcion a(){}这些内容删除
#可以在shell脚本中像使用其他变量一样使用$1变量。shell脚本会自动将命令行参数的值分配给变量，不需要你作任何处理。
#注意，当需要读取外部变量时脚本不能用函数，不然会读取不到$1的值
function b() {
a=$[ $1 * $2]
echo "第一个数的值为 $1 "
echo "第二个数的值为 $2 "
echo "他们的乘积是 $1 * $2 = $a "
#当有多个变量时，变量与变量之间需要用空格隔开
}


function c(){
echo " hello, $1 欢迎来到德莱联盟"
}
#在前面的例子中，用到的命令行参数都是数值。也可以在命令行上用文本字符串。
#shell将输入到命令行的字符串值传给脚本。但碰到含有空格的文本字符串时就会出现问题:
#每个参数都是用空格分隔的，所以shell会将空格当成两个值的分隔符。要在参数值中包含空格，那么就要用到引号（双引号，单引号都可以）#将文本字符串作为参数传递时，引号并非数据的一部分。它们只是表明数据的起止位置。


#如果脚本需要的命令行参数不只9个，那就要更改变量名了，在第9个变量之后，必须在变量周围加上花括号比如 ${10}
function d(){
echo "第一个数  $1"
echo "第二个数  $2"
echo "第三个数  $3"
echo "第四个数  $4"
echo "第五个数  $5"
echo "第六个数  $6"
echo "第七个数  $7"
echo "第八个数  $8"
echo "第九个数  $9"
echo "第十个数  ${10}"
echo "第十一个数  ${11}"
}
#读取脚本名
function e(){
echo "将0参数设置为：$0"
}
#用 sh "脚本名称" 这样执行$0返回的值是脚本名称
#但是把脚本授予可执行权限，然后用 ./“脚本名称” 这种方式来执行的话 返回的结果是./“脚本名称”，如果加了绝对路径，那么返回结果就是/home/yuer/shell/useriput/"脚本名称了"
#但是这里存在一个潜在的问题。如果使用另一个命令来运行shell脚本，命令会和脚本名混在 一起，出现在$0参数中。

#其实$0就是输入的命令，只是会隐藏一些而已

#这还不是唯一的问题。当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时， 变量$0就会使用整个路径。

#如果你要编写一个根据脚本名来执行不同功能的脚本，就得做点额外工作。你得把脚本的运 行路径给剥离掉。另外，还要删除与脚本名混杂在一起的命令。幸好有个方便的小命令可以帮到我们。basename命令会返回不包含路径的脚本名。
function f(){
name=$(basename $0)
echo "当前脚本名称为 $name" 
}
#现在好多了。可以用这种方法来编写基于脚本名执行不同功能的脚本。

echo "当前脚本名$0 " 






name=$(basename $0)
if [ $name = "addem" ]
then
  total=$[ $1 + $2 ] 
elif [ $name = "multem"]
then
  total=$[ $1 * $2]
fi
echo "计算值为 $total"







