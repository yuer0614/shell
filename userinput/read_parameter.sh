#!/bin/bash


#bash shell会将一些称为位置参数(positional parameter)的特殊变量分配给输入到命令行中的 所有参数。这也包括shell所执行的脚本名称。位置参数变量是标准的数字:$0是程序名，$1是第 一个参数，$2是第二个参数，依次类推，直到第九个参数$9。
#通俗的说是$0是脚本名称，$1-$9是sh 脚本名称 $1-$9，就是执行脚本的时候在脚本名称后输入9个参数可以用$1-$9来获取到
function a(){
i=1
for (( a = 1 ; a <= $1 ; a++ ))   #$1是外部输入的一个变量，a与外面输入的变量作比较，循环是 外面变量的值* a,a从1开始
do
   echo "本次循环a 为$a ,i 为 $i"
  i=$[ $i * $a]
done
echo "$1的乘阶是 $i"
}
#想要使用这个脚本把 funcion a(){}这些内容删除
#可以在shell脚本中像使用其他变量一样使用$1变量。shell脚本会自动将命令行参数的值分配给变量，不需要你作任何处理。
#注意，当需要读取外部变量时脚本不能用函数，不然会读取不到$1的值
function b() {
a=$[ $1 * $2]
echo "第一个数的值为 $1 "
echo "第二个数的值为 $2 "
echo "他们的乘积是 $1 * $2 = $a "
#当有多个变量时，变量与变量之间需要用空格隔开
}


function c(){
echo " hello, $1 欢迎来到德莱联盟"
}
#在前面的例子中，用到的命令行参数都是数值。也可以在命令行上用文本字符串。
#shell将输入到命令行的字符串值传给脚本。但碰到含有空格的文本字符串时就会出现问题:
#每个参数都是用空格分隔的，所以shell会将空格当成两个值的分隔符。要在参数值中包含空格，那么就要用到引号（双引号，单引号都可以）#将文本字符串作为参数传递时，引号并非数据的一部分。它们只是表明数据的起止位置。


#如果脚本需要的命令行参数不只9个，那就要更改变量名了，在第9个变量之后，必须在变量周围加上花括号比如 ${10}
function d(){
echo "第一个数  $1"
echo "第二个数  $2"
echo "第三个数  $3"
echo "第四个数  $4"
echo "第五个数  $5"
echo "第六个数  $6"
echo "第七个数  $7"
echo "第八个数  $8"
echo "第九个数  $9"
echo "第十个数  ${10}"
echo "第十一个数  ${11}"
}
#读取脚本名
function e(){
echo "将0参数设置为：$0"
}
#用 sh "脚本名称" 这样执行$0返回的值是脚本名称
#但是把脚本授予可执行权限，然后用 ./“脚本名称” 这种方式来执行的话 返回的结果是./“脚本名称”，如果加了绝对路径，那么返回结果就是/home/yuer/shell/useriput/"脚本名称了"
#但是这里存在一个潜在的问题。如果使用另一个命令来运行shell脚本，命令会和脚本名混在 一起，出现在$0参数中。

#其实$0就是输入的命令，只是会隐藏一些而已

#这还不是唯一的问题。当传给$0变量的实际字符串不仅仅是脚本名，而是完整的脚本路径时， 变量$0就会使用整个路径。

#如果你要编写一个根据脚本名来执行不同功能的脚本，就得做点额外工作。你得把脚本的运 行路径给剥离掉。另外，还要删除与脚本名混杂在一起的命令。幸好有个方便的小命令可以帮到我们。basename命令会返回不包含路径的脚本名。
function f(){
name=$(basename $0)
echo "当前脚本名称为 $name" 
}
#现在好多了。可以用这种方法来编写基于脚本名执行不同功能的脚本。
function g(){
echo "当前脚本名$0 " 
name=$(basename $0)
if [ $name = "addem" ]
then
  total=$[ $1 + $2 ]
elif [ $name = "multem" ]
then
  total=$[ $1 * $2]
fi
echo "计算值为 $total"
}
#本例从read_read_parameter.sh脚本中创建了两个不同的文件名:一个通过复制文件创建(addem)，另一个通过软连接创建(multem)。在两种情况下都会先获得脚本的基本名称，然后根据该值执行相应的功能。


#测试参数

#刚刚那个脚本指定了两个变量，$1与$2如果少了其中任何一个参数都会报错。所以脚本执行的时候一定要判断有没有把变量输入完全
#当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。这种写 脚本的方法并不可取。在使用参数前一定要检查其中是否存在数据。

function h(){
name=$(basename $0)
if [ $name = "addem" ]
then
  if [ $1 -n ] 
  then
  echo "未输入变量请在执行脚本时输入变量"
  exit 1
  else
  total=$[ $1 + $2 ]
  fi
elif [ $name = "multem" ]
then
  total=$[ $1 * $2]
else
if [ $1 -n ]
  then
  echo "未输入变量请在执行脚本时输入变量"
  exit 1
  total=$[ $1 + $2 ]
  else
  total=$[ $1 + $2 ]  
  fi
fi
echo "计算值为 $total"
}
#这里我使用了-n来判断$1与$2是否为空值

#还有上一次我们用了-n来测试变量是否为空，但是还有一种办法就是$#   特殊变量$#含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊 变量，就跟普通变量一样。

echo "运行脚本的时候你一共输入了$# 个变量"

#现在用$#来修改一些上面那个脚本



echo "当前脚本名$0 " 
name=$(basename $0)
if [ $# -ne 2 ]
then
  echo "启动脚本变量不满足脚本内容请重试"
  exit 1
else
  if [ $name = "addem" ]
  then
    total=$[ $1 + $2 ]
  elif [ $name = "multem" ]
  then
  total=$[ $1 * $2]
  echo "计算值为 $total"
  fi
fi
